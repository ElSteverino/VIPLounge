// MARK: Change Log
/***************************************************************************************************************************************
 
 VIPLoungeInteractor.swift
 VIPLounge
 
 This file was generated by the Clean Swift Xcode Templates so you can apply clean architecture to your iOS and Mac projects,
 see http://clean-swift.com
 
 
 4/24/18 <sdm>
 â€¢ Initial Code
 
 ***************************************************************************************************************************************/

import Cocoa



// MARK: -
/*====================================================================================================================================*/

protocol VIPLoungeBusinessLogic {
    
    func updateVIPCode( request: VIPLounge.Update.Request )
    func displayInitialVIPCode(  request: VIPLounge.Display.Request )
    
}



// MARK: -
/*====================================================================================================================================*/

protocol VIPLoungeDataStore {  }



// MARK: -
/*====================================================================================================================================*/

class VIPLoungeInteractor: VIPLoungeBusinessLogic, VIPLoungeDataStore {
    
    var presenter: VIPLoungePresentationLogic?
    var worker: VIPLoungeWorker?
    
    
    // MARK: - UseCase: displayInitialVIPCode
    /*====================================================================================================================================*/
    
    func displayInitialVIPCode(  request: VIPLounge.Display.Request ) {
    
        var code: NSMutableAttributedString = NSMutableAttributedString()
        
        if let rtfPath = Bundle.main.url(forResource: Constant.boilerPlateName, withExtension: Constant.boilerPlateType ) {

            do {
                
                let attributedStringWithRtf: NSMutableAttributedString = try NSMutableAttributedString(url: rtfPath, options: [NSAttributedString.DocumentReadingOptionKey.documentType: NSAttributedString.DocumentType.rtf], documentAttributes: nil)
                
                code = attributedStringWithRtf
                
            } catch let error {
                
                print("Got an error \(error)")
                
            }
        }
                
        let response = VIPLounge.Update.Response( vipCode: code )
        presenter?.presentVIPCode( response: response )

    }
    
    
    // MARK: - UseCase: updateVIPCode
    /*====================================================================================================================================*/
    func updateVIPCode( request: VIPLounge.Update.Request ) {
        
        var code: NSMutableAttributedString = NSMutableAttributedString()
        
        if let rtfPath = Bundle.main.url(forResource: "CodeBoilerPlate", withExtension: "rtf") {
            
            do {
                
                let attributedStringWithRtf: NSMutableAttributedString = try NSMutableAttributedString(url: rtfPath, options: [NSAttributedString.DocumentReadingOptionKey.documentType: NSAttributedString.DocumentType.rtf], documentAttributes: nil)
                
                code = attributedStringWithRtf
                if request.parameters.sceneName != ""           { code = code.replacingOccurrences(of: "$sceneName$", with: request.parameters.sceneName ) }
            
                if request.parameters.useCase != ""             { code = code.replacingOccurrences(of: "$useCase$", with: request.parameters.useCase ) }
                if request.parameters.request != ""             { code = code.replacingOccurrences(of: "$request$", with: request.parameters.request ) }
                if request.parameters.requestType != ""         { code = code.replacingOccurrences(of: "$requestType$", with: request.parameters.requestType ) }
                if request.parameters.response != ""            { code = code.replacingOccurrences(of: "$response$", with: request.parameters.response ) }
                if request.parameters.responseType != ""        { code = code.replacingOccurrences(of: "$responseType$", with: request.parameters.responseType ) }
                if request.parameters.viewModel != ""           { code = code.replacingOccurrences(of: "$viewModel$", with: request.parameters.viewModel ) }
                if request.parameters.viewModelType != ""       { code = code.replacingOccurrences(of: "$viewModelType$", with: request.parameters.viewModelType ) }
                if request.parameters.viewerMethod != ""        { code = code.replacingOccurrences(of: "$viewerMethod$", with: request.parameters.viewerMethod ) }
                if request.parameters.interactorMethod != ""    { code = code.replacingOccurrences(of: "$interactorMethod$", with: request.parameters.interactorMethod ) }
                if request.parameters.presenterMethod != ""     { code = code.replacingOccurrences(of: "$presenterMethod$", with: request.parameters.presenterMethod ) }
                
            } catch let error {
                print("Got an error \(error)")
            }
        }
        
        let response = VIPLounge.Update.Response( vipCode: code )
        presenter?.presentVIPCode( response: response )
        
    }
}



// MARK: - NSMutableAttributedString extension
/*==================================================================================================================================*/

fileprivate extension  NSMutableAttributedString {


    
    /*==================================================================================================================================*/
    /**
     
     Returns a new string in which all occurrences of a target string in a specified range of the string are replaced by another given string.
     
     - parameter stringToReplace: The target string to replace
     - parameter newStringPart: Replacement string
     
     */
    
    func replacingOccurrences( of stringToReplace: String, with newStringPart: String ) -> NSMutableAttributedString {
        
        let mutableAttributedString = mutableCopy( ) as! NSMutableAttributedString
        let mutableString = mutableAttributedString.mutableString
        
        while mutableString.contains( stringToReplace ) {
            
            let rangeOfStringToBeReplaced = mutableString.range( of: stringToReplace )
            mutableAttributedString.replaceCharacters( in: rangeOfStringToBeReplaced, with: newStringPart )
            
        }
        
        return mutableAttributedString
        
    }
    
    
}



// Public Domain, 2018 by Steve Marcotte
//
// Notwithstanding the foregoing, you may not use, copy, modify, merge, publish, distribute, sublicense, create a derivative work,
// and/or sell copies of the Software in any work that is designed, intended, or marketed for pedagogical or instructional purposes
// related to programming, coding, application development, or information technology.  Permission for such use, copying, modification,
// merger, publication, distribution, sublicensing, creation of derivative works, or sale is expressly withheld.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

